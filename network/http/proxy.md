# 代理
Web代理服务器是网络的中间实体。代理位于客户端和服务器之间，扮演**中间人**的角色，在各端点之间来回传送HTTP报文。
## Web的中间实体
Web上的代理服务器是**代表客户端**完成事务处理的中间人（不同于反向代理）。如果没有Web代理，HTTP客户端就要直接与HTTP服务器进行对话。

HTTP的代理服务器既是Web服务器又是Web客户端。

单个客户端专用的代理被称为**私有代理**；众多客户端共享的代理被成为**公共代理**。

### 代理与网关的对比
* 代理连接的是两个或者多个使用**相同**协议的应用程序。
* 网关连接的是两个或者多个使用**不同**协议的应用程序。

## 为什么使用代理
代理服务器可以看到并接触到所有流过的HTTP流量，所以代理可以监视流量并对其进行修改，以实现很多有用的Web增值服务。

* 儿童过滤器：阻止儿童访问成人内容。
* 文档访问控制
* 安全防火墙
* Web缓存
* 反向代理：可以假扮服务器。
* 内容路由器：代理服务器可以作为“内容路由器”使用，根据因特网流量状况以及内容类型将请求导向特定的服务器。
* 转码器
* 匿名者：匿名者代理会主动从HTTP报文中删除身份特性（Client-IP，From首部，Referer首部，cookie等）

## 代理部署位置
根据目标和用途，代理可以部署在以下位置：
* 出口代理：本地网络的出口点
* 访问（入口）代理：部署在ISP的访问点，用于处理来自客户端的聚合请求，通常使用缓存代理。
* 反向代理：部署在网络边缘，在Web服务器之前作为服务器的替代物使用。
* 网络交换代理
### 代理的层次结构
下一个入口代理成为父代理，下一个出口代理成为子代理。
**靠近源服务器的成为父代理**。

代理层次结构的内容路由：代理服务器可以根据众多因素，将报文转发给一个不断变化的代理服务器和原始服务器集。

动态选择父代理的例子：
* 负载均衡
* 地理位置附近的路由
* 协议/类型路由
* 基于订购的路由

### 代理是如何获取流量的
* 修改客户端
* 修改网络（拦截代理）
* 修改DNS
* 修改Web服务器（HTTP重定向）

## 客户端的代理设置
### 手工配置
很多Web客户端都允许使用**手工**配置代理：指定代理服务器的主机和端口。
### PAC文件
Proxy Auto-Configuration(PAC)文件是一个小型的JavaScript程序，可以在运行过程中计算代理设置，是一种动态的代理配置解决方案。访问每个文档时，JavaScript都会选择恰当的代理服务器。

每个PAC文件都必须定义一个名为**FindProxyForURL(url,host)**的函数，用来计算访问URI时使用的适当的代理服务器。

**(url,host)->proxy**

FindProxyForURL函数的返回值如下：

* DIRECT    不经过任何代理，直接进行连接
* PROXY host:port 使用代理服务器host:port
* SOCKS host:port 使用SOCKS服务器host:port

### WPAD
Web Proxy Auto-Discovery Protocol（WPAD）算法会使用发现机制的逐级上升策略自动地为浏览器查找合适的PAC文件。

WPAD会使用一系列的资源发现技术来判定适当的PAC文件。

  
## 其他
### 代理URI与服务器URI有何不同
* 没有设置代理时，客户端发送**部分URI**。
* 设置代理时，客户端发送**完整URI**。

``` http
GET /index.hmtl HTTP/1.0
User-Agent: MyTestAgent v1.0
```

``` http
GET http://www.mytest.com/index.html HTTP/1.0
User-Agent: MyTestAgent v1.0
```

### 与虚拟主机一样的问题
* 显式的代理要求客户端在请求报文中发送完整的URI。
* 虚拟主机Web服务器要求使用Host首部来承载主机和端口信息。

### 拦截代理会收到部分URI

### 代理既可以处理代理请求，也可以处理服务器请求

### 转发过程中对URI的修改
代理服务器要在转发报文时修改URI的话，需要特别小心。

HTTP规范禁止一般的拦截代理在转发URI时重写其绝对路径部分。唯一的例外时可以用“/”来取代空路径。

### URI的客户端自动扩展和主机名解析
* 没有代理时URI的解析：浏览器自动进行扩展、DNS查找等
* 显示代理时URI的解析：用户URI会被直接发送给代理，浏览器不再执行所有的自动扩展等功能
* 拦截代理时URI的解析

## 追踪报文
随着代理的逐渐流行，我们要能够追踪经过代理的报文流，以检测出各种问题，其重要性就跟追踪经过不同交换机和路由器传输的IP分组流一样。
### Via首部
Via首部列出了报文途径的每个中间点（代理或者网络）有关的信息。报文每经过一个中间点，都必须将这个中间点添加到**Via列表的末尾**。

Via首部字段用于记录报文的转发，诊断报文循环，标识请求/响应链上所有发送者的协议能力。

代理也可以用Via首部来检测网络中的路由循环。代理应该在发送一条请求之前，在Via首部插入一个与其自身有关的独特字符串，并在输入的请求中查找这个字符串，以检测网络中是否存在路由循环。

一个Via首部可以包含多个路标（way point），由**逗号**隔开。每个路标是一个独立的代理服务器或者网络。

一个路标最多可以包含四个组件：
* 协议名： 可选，默认是HTTP
* 协议版本： 必选
* 节点名： 必选，节点名包括主机名和端口号（端口号可选，默认是协议对应的端口号，比如HTTP默认是80）
* 节点注释： 可选

例子：

``` http
Via: HTTP/1.0 www.interproxy1.com:80 (comments of proxy 1), HTTP/1.1 www.interproxy2.com:80 (comments of proxy 2)
```

请求和响应报文都会经过代理进行传输，因此，请求和响应报文中都要由Via首部。
请求和响应通常都是通过同一条TCP连接进行传送的，所以响应报文会沿着与请求报文相同的路径回传。因此，响应报文的Via首部基本上总是与请求报文的Via首部相反。

Server首部字段对原始服务器使用的软件进行了描述。如果响应报文是通过代理转发的，一定要确保代理没有修改Server首部。
**Server首部是用于原始服务器的。代理应该添加的是Via条目。**

### HTTP TRACE
代理服务器可以在转发报文时对其进行修改：可以添加、修改或者删除**首部字段**，也可以将**主体部分**转换成不同的格式。

通过HTTP/1.1的TRACE方法，用户可以跟踪经代理传输的请求报文，观察报文经过了哪些代理，以及每个代理是如何对请求报文进行修改的。

* 当TRACE请求到达目的服务器时，整条请求报文都会被封装在一条HTTP响应的主体中回送给发送端。
* 当TRACE响应到达客户端时，客户端可以检查服务器收到的确切报文，以及它经过的代理列表（在Via首部）。

TRACE响应的Content-Type为message/http，状态为200 OK。

Max-Forwards首部可以限制TRACE和OPTIONS请求所经过的代理跳数。
当Max-Forwards为0时，当前服务器即使不是最终的源服务器，也必须将响应回送给客户端，而不能继续转发。

## 代理认证
代理可以作为访问控制设备使用。
HTTP定义了一种名为代理认证（Proxy Authentication）的机制，这种机制可以阻止对内容的请求，直到用户向代理提供了有效的访问权限认证为止。
* 对受限内容的请求到达代理服务器时，代理服务器返回一个要求使用访问凭证的407 Proxy Authorization Required状态码，以及一个用于描述怎样提供凭证的Proxy-Authenticate首部字段。
* 客户端收到407响应时，尝试从本地数据库中，或者通过提示用户来搜集所需要的凭证。
* 只要提供了凭证，客户端就会重新发送请求，在Proxy-Authorization首部字段中提供所要求的凭证。
* 如果凭证有效，代理就会将原始请求沿着传输链路向下传输；否则就发送另一条407应答。

***如果链路中存在多个代理，且多个代理都要进行认证，代理认证通常无法很好的工作。***

## 代理的互操作性
### 处理代理不支持的首部和方法
代理必须对不认识的**首部字段**进行转发，而且必须维持**同名首部字段的相对顺序**。

对于不认识的**方法**，只要有可能，就应该尝试着将报文转发到下一跳节点上去。

### OPTIONS：发现对可选特性的支持
通过HTTP OPTIONS方法，客户端（或者代理）可以发现Web服务器或者服务器上某特定资源所支持的方法。

### Allow首部
Allow首部字段列出了请求URI标识的资源所支持的方法列表。
如果请求URI为*的话，列出的就是整个服务器支持的方法列表。

``` http
Allow: GET, HEAD, PUT
```
可以将Allow首部作为**请求首部**，建议在新的资源上支持某些方法。如此，并不要求服务器支持这些方法，但是服务器应该在响应报文中包含一个Allow首部，列出它实际支持的方法。

代理不能对无法理解的Allow首部方法进行修改。

