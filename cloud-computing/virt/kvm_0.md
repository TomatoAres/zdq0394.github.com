# KVM基本原理
## KVM概述
KVM的全称是Kernel Virtual Machine。KVM虚拟机最初是由一个以色列的创业公司Qumranet开发的。为了简化开发，KVM的开发人员并没有选择从底层开始新写一个Hypervisor，而是选择了**基于Linux Kernel**，通过**加载新的模块**从而使Linux Kernel本身变成一个**Hypervisor**。

2006年10月，KVM模块的源代码呗正式接纳进入Linux Kernel，成为内核源代码的一部分。

2008年9月，Redhat收购了Qumranet并在自己的发行版中使用KVM替代Xen。KVM的核心组件从Linux2.6.20开始包含进主干。KVM的用户空间组件从1.3版本开始包含在QEMU主干中。

KVM是基于**硬件虚拟化扩展**（Intel VT或者AMD-V）技术，是**Linux完全原生**的**全虚拟化**解决方案。


## KVM原理
KVM包含一个可加载的Kernel module: kvm.ko和一个处理器相关的module：kvm-intel.ko or kvm-amd.ko。

KVM模块是KVM虚拟机的核心部分。其主要功能个功能是初始化CPU硬件，打开**虚拟化模式**，然后将虚拟客户机运行在**客户机模式**下，并对虚拟客户机的运行提供一定的支持。

KVM仅支持硬件虚拟化。打开并初始化系统硬件以支持虚拟机的运行，是KVM模块的职责所在。在被内载加载的时候，KVM模块会先**初始化内部的数据结构**；做好准备之后，KVM模块检测系统当前的CPU，然后打开CPU控制寄存器CR4中的虚拟化模式开关；通过执行VMXON指令将宿主操作系统（包括KVM模块本身）置于虚拟化模式中的**内核模式**；最后，KVM模块创建特殊设备文件/dev/kvm并等待来自用户空间的命令（QEMU）。接下来，虚拟机的创建和运行将是一个**用户空间**的应用程序**QEMU和KVM模块**相互配合的过程。

KVM模块与用户空间QEMU的通信接口主要是一系列针对特殊设备文件（/dev/kvm）的IOCTL调用。KVM模块加载之初，只存在/dev/kvm文件，而针对该文件等最重IOCTL调用就是“创建虚拟机”。在这里“创建虚拟机”可以理解成KVM为了某个特定的虚拟客户机（用户空间程序创建并初始化）创建对应的**内核数据结构**，同时KVM还会返回**一个文件句柄来代表所创建的虚拟机**。针对该文件句柄的IOCTL调用可以对虚拟机做相应的管理，比如创建用户空间虚拟地址和客户机物理地址及真实内存物理地址的映射关系，再比如创建多个可供运行的虚拟处理器（vCPU）。同样，KVM模块会为每一个创建出来的vCPU生成对一个的文件句柄，对vCPU相应的文件句柄进行相应的IOCTL调用，就可以对vCPU进行管理。

针对vCPU最重要的IOCTL调用就是“执行vCPU”。通过它，用户空间准备好的虚拟机在KVM模块的支持下，被置于虚拟化模式中的**客户机模式**下，开始执行二进制指令，在该模式下，所有敏感的二进制指令都会被处理器捕捉到，处理器在保存现场之后自动切换到**内核模式**，由KVM决定进一步处理（要么由KVM模块直接处理，要么返回用户空间交由用户空间程序QEMU处理）。

除了处理器的虚拟化，内存虚拟化也是由KVM模块实现的。

在KVM架构中，虚拟机实现为常规的Linux进程，由标准的Linux调度程序进行调度。事实上，每个虚拟CPU显示为一个常规的Linux线程。

KVM本身不执行任何模拟，需要用户空间应用程序(QEMU)通过/dev/kvm接口设置一个客户机虚拟服务器的地址空间，向它提供模拟的I/O，并将它的视频显示映射回宿主的显示屏。





	