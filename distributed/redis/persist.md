# Redis持久化
Redis提供了两种持久化的方式：RDB（Redis Database）和AOF（Append Only File）。
* RDB：在不同的时间点，将Redis存储的数据生成快照并存储到磁盘等介质上。
* AOF：将Redis执行过的所有指令记录下来，在下次Redis重启时，只需要把AOF重放一遍实现数据恢复。

两种方式都开启的情况下，Redis优先使用AOF方式恢复数据。

Redis可以将RDB和AOF功能都关闭从而disable数据持久化功能，Redis称为一个纯内存数据库。

对于我们应该选择RDB还是AOF，官方的建议是**两个同时使用**。
这样可以提供更可靠的持久化方案。
## RDB
Redis会单独创建（fork）一个子进程进行持久化，而主进程是不会进行IO操作的。Redis会先把数据写入到一个临时文件，待持久化过程结束了，才会用这个临时文件替换上次持久化好的文件。

RDB方式持久化只适合于**数据完整性不是非常敏感的场景**。即使每隔5分钟做一次快照，也存在丢失5分钟数据的可能性。但是对于大规模的数据恢复时，RDB方式要比AOF方式快速。

## AOF
通过配置redis.conf中的appendonly yes就可以打开AOF功能。
如果有**写操作（如SET等）**，redis就会把它追加到AOF文件的末尾。

默认的AOF持久化策略是**每秒钟fsync一次**（fsync是指把缓存中的写指令记录到磁盘中）。
在这种情况下，redis仍然可以保持很好的处理性能。
即使redis故障，也只会丢失最近1秒钟的数据。

在追加日志时，如果恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整。
Redis提供了**redis-check-aof**工具，可以用来进行日志修复。

因为采用了追加方式，如果不做任何处理的话，AOF文件会变得越来越大。
为此，redis提供了**AOF文件重写（rewrite）机制**，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。

举个例子，假如我们调用了100次INCR指令，在AOF文件中就要存储100条指令，但这明显是很低效的，完全可以把这100条指令合并成一条SET指令，这就是重写机制的原理。

## AOF重写
在重写即将开始之际，redis会创建（fork）一个**重写子进程**。
这个子进程会首先读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。

与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。

当**重写子进程**成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。

当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中了。